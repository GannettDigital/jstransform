package generate

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"io"
	"io/ioutil"
	"path"
	"path/filepath"
	"strings"
	"text/template"
	"time"
)

// AvroCFWriter creates a Avro Container file containing the data from the struct that implements this interface.
type AvroCFWriter interface {
	WriteAvroCF(io.Writer, time.Time) error
}

// AvroCFDeleter implements functionality to write an Avro Container file with the metadata field AvroDeleted set
// to true. This is a record that a delete of the given item occurred but is writing a new Container File. This enables
// adhering to the the Avro Schema for the given data type and tracking history of changes for any given ID.
type AvroCFDeleter interface {
	WriteAvroDeletedCF(io.Writer, time.Time) error
}

// AvroTime converts the given time.Time into an int64 compatible with an Avro timestamp.millis logical type.
// http://avro.apache.org/docs/current/spec.html#Date
func AvroTime(t time.Time) int64 {
	return t.UnixNano() / (int64(time.Millisecond) / int64(time.Nanosecond))
}

// AvroTimeSlice converts the given []time.Time into a []int64 leveraging AvroTime.
func AvroTimeSlice(times []time.Time) []int64 {
	newTimes := make([]int64, len(times))
	for i, t := range times {
		newTimes[i] = AvroTime(t)
	}
	return newTimes
}

// AvroOptionalTime converts the given *time.Time into an int64 compatible with an Avro timestamp.millis logical type.
// It sets the value to 0 if the pointer is nil
// http://avro.apache.org/docs/current/spec.html#Date
func AvroOptionalTime(t *time.Time) int64 {
	if t == nil {
		return 0
	}
	return t.UnixNano() / (int64(time.Millisecond) / int64(time.Nanosecond))
}

// AvroOptionalTimeSlice converts the given []time.Time into a []int64 leveraging AvroTime
// If the array is empty or all values are nil a nil slice is returned.
func AvroOptionalTimeSlice(times []*time.Time) []int64 {
	var newTimes []int64
	for _, t := range times {
		if t == nil {
			continue
		}
		newTimes = append(newTimes, AvroTime(*t))
	}
	if len(newTimes) < 1 {
		return nil
	}
	return newTimes
}

// buildAvroHelperFunctions creates functions for the given type which make it easy to output an Avro container file.
// The functions are based on the generated Go struct and the serialization code generated by the gogen-avro package.
func buildAvroHelperFunctions(name, goSourcePath, importPath string) error {
	dir := filepath.Dir(goSourcePath)
	values := map[string]string{
		"avroImport":  path.Join(importPath, "avro", strings.ToLower(name)),
		"avroPackage": strings.ToLower(name),
		"name":        name,
		"pkgName":     filepath.Base(dir),
	}

	fm, err := newAvroFieldMapper(name, goSourcePath)
	if err != nil {
		return fmt.Errorf("failed to initialize field mapper: %v", err)
	}
	mapped, err := fm.generate()
	if err != nil {
		return fmt.Errorf("failed to generate struct field mappings: %v", err)
	}
	values["preProcessing"], values["fieldMapping"] = mapped.preProcessing, mapped.fieldMapping

	if err := writeCodeTemplate(avroTemplate, values, filepath.Join(dir, strings.ToLower(name)+"_avro.go")); err != nil {
		return err
	}

	return writeCodeTemplate(avroTestTemplate, values, filepath.Join(dir, strings.ToLower(name)+"_avro_test.go"))
}

// mappedFields contains the data needed to build a new avro struct.
type mappedFields struct {
	fieldMapping  string // the lines like `avroStructField: generatedStructField,` which go within a struct initialization
	preProcessing string // contains go code that does any preProcessing needed before the struct initialization
	name          string // the name of the generated struct these fields are a mapping for, only set for named nested structs
}

// avroFieldMapper provides methods to map the fields in an Avro Struct with correct fields and converted fields from
// a generated Go struct that was the original source of the Avro struct.
type avroFieldMapper struct {
	avroPackagePath         string // The filesystem path to the go source directory containing the Avro structs
	generatedSourcePath     string // The path to the go source file for the generated struct
	packageName             string
	structName              string
	unionTemplates          map[string]*template.Template
	structSliceTemplate     *template.Template
	unionNullStructTemplate *template.Template
}

func newAvroFieldMapper(name, goSourcePath string) (*avroFieldMapper, error) {
	unionTypes := map[string]string{"UnionNullDouble": unionNullDouble, "UnionNullLong": unionNullLong, "UnionNullString": unionNullString}
	unionTemplates := make(map[string]*template.Template, len(unionTypes))
	for unionName, templateSource := range unionTypes {
		tmpl, err := template.New("").Parse(templateSource)
		if err != nil {
			return nil, fmt.Errorf("failed to parse template for %q: %v", unionName, err)
		}
		unionTemplates[unionName] = tmpl
	}

	structSliceTemplate, err := template.New("").Parse(avroStructSliceTemplate)
	if err != nil {
		return nil, fmt.Errorf("failed to parse avroStructSliceTemplate: %v", err)
	}

	unionNullStructTemplate, err := template.New("").Parse(unionNullStruct)
	if err != nil {
		return nil, fmt.Errorf("failed to parse unionNullStruct: %v", err)
	}

	lowerName := strings.ToLower(name)
	return &avroFieldMapper{
		avroPackagePath:         filepath.Join(filepath.Dir(goSourcePath), "avro", lowerName),
		generatedSourcePath:     goSourcePath,
		packageName:             lowerName,
		structName:              name,
		structSliceTemplate:     structSliceTemplate,
		unionTemplates:          unionTemplates,
		unionNullStructTemplate: unionNullStructTemplate,
	}, nil
}

// generate discovers an Avro struct and the generated struct with the given name. It then walks
// through the Avro struct fields matching the appropriate value from the generated struct.
// In the case of timestamps a conversion must be done, for arrays of timestamps this conversion is done by adding a
// for loop to the preProcessing string.
func (fm *avroFieldMapper) generate() (mappedFields, error) {
	generatedFieldsMap, err := mapGeneratedFields(fm.structName, fm.generatedSourcePath)
	if err != nil {
		return mappedFields{}, fmt.Errorf("failed to parse generated Go struct: %v", err)
	}

	avroStruct, err := parseGoStruct(fm.structName, fm.avroPackagePath)
	if err != nil {
		return mappedFields{}, fmt.Errorf("failed to parse Avro Go struct: %v", err)
	}
	avroFields := findStructFields(avroStruct)
	if avroFields == nil {
		return mappedFields{}, errors.New("failed to parse fields from avro go struct")
	}

	return fm.generateFields("", avroFields, generatedFieldsMap)
}

// generateChildStruct creates a mappedFields similar to generate but with a few starting assumptions appropriate for
// child structs.
func (fm *avroFieldMapper) generateChildStruct(expr ast.Expr, name, prefix string, avroFields *ast.FieldList) (mappedFields, *ast.FieldList, error) {
	var stype *ast.StructType
	var fields *ast.FieldList
	var structName string

	if s, ok := expr.(*ast.StarExpr); ok {
		expr = s.X
	}

	if s, ok := expr.(*ast.StructType); ok {
		stype = s
		fields = stype.Fields
	} else {
		ident, ok := expr.(*ast.Ident)
		if !ok {
			return mappedFields{}, nil, fmt.Errorf("expected generated field %q to be a struct type or identifier for a named struct", name)
		}
		structName = ident.Name
		n, err := parseGoStruct(structName, filepath.Dir(fm.generatedSourcePath))
		if err != nil {
			return mappedFields{}, nil, fmt.Errorf("unable to find type named %q: %v", name, err)
		}
		if s, ok := n.Type.(*ast.StructType); ok {
			stype = s
		} else {
			return mappedFields{}, nil, fmt.Errorf("type %q is not a struct", name)
		}
	}
	generatedChildFieldMap, err := mapFields(stype.Fields, fm.generatedSourcePath)
	if err != nil {
		return mappedFields{}, nil, fmt.Errorf("failed to parse generated Go struct: %v", err)
	}
	mappedStruct, err := fm.generateFields(prefix, avroFields, generatedChildFieldMap)
	if err != nil {
		return mappedFields{}, nil, fmt.Errorf("failed generating mappings for field %s: %v", name, err)
	}
	mappedStruct.name = structName

	return mappedStruct, fields, nil
}

func (fm *avroFieldMapper) generateFields(prefix string, avroFields *ast.FieldList, generatedFieldsMap map[string]*ast.Field) (mappedFields, error) {
	var mapped mappedFields
	var fields []string
	for _, f := range avroFields.List {
		if len(f.Names) == 0 {
			return mappedFields{}, errors.New("unknown embedded field in Avro struct")
		}
		name := f.Names[0].Name
		if strings.HasPrefix(name, "Avro") { // skip metadata fields which are populated in the templated code
			continue
		}
		generatedField, ok := generatedFieldsMap[name]
		if !ok {
			return mappedFields{}, fmt.Errorf("no mapping found for field %q", name)
		}

		mappedField, err := fm.generateFieldValue(name, prefix, f.Type, generatedField)
		if err != nil {
			return mappedFields{}, fmt.Errorf("failed generating field mapping for field %q: %v", name, err)
		}

		fields = append(fields, fmt.Sprintf("%s: %s,", name, mappedField.fieldMapping))
		mapped.preProcessing += mappedField.preProcessing
	}
	mapped.fieldMapping = strings.Join(fields, "\n")

	return mapped, nil
}

// generateFieldValue will create the code to set the value of the given avroField from the given generatedField.
// This is straightforward for scalar types but for structs and arrays may require recursively various functions.
func (fm *avroFieldMapper) generateFieldValue(name, prefix string, avroType ast.Expr, generatedField *ast.Field) (mappedFields, error) {
	switch f := avroType.(type) {
	case *ast.StarExpr:
		mappedField, err := fm.generateFieldValue(name, prefix, f.X, generatedField)
		if err != nil {
			return mappedFields{}, err
		}

		// check for a nil pointer
		if _, ok := generatedField.Type.(*ast.StarExpr); ok {
			return mappedFields{
				fieldMapping:  fm.generateNullableFieldValue(name, prefix, mappedField.name, fmt.Sprintf("&%s", mappedField.fieldMapping)),
				preProcessing: mappedField.preProcessing,
			}, nil
		}
		return mappedFields{
			fieldMapping:  fmt.Sprintf("&%s", mappedField.fieldMapping),
			preProcessing: mappedField.preProcessing,
			name:          prefix + name,
		}, nil
	case *ast.StructType: // This handles anonymous structs in the Avro struct but the generated code never has those
		return mappedFields{}, errors.New("anonymous structs in the Avro struct are not handled")
	case *ast.ArrayType:
		if _, ok := generatedField.Type.(*ast.ArrayType); !ok {
			return mappedFields{}, fmt.Errorf("avro type is array but generated isn't for field %q", name)
		}
		if ptr, ok := f.Elt.(*ast.StarExpr); ok {
			return fm.generateFieldValue(name, prefix, ptr.X, generatedField)
		}
		return fm.generateFieldValue(name, prefix, f.Elt, generatedField)
	case *ast.Ident: // This covers covers all of the basic scalar types but also identifiers for other defined types
		typeName := f.Name
		switch typeName { // handle builtin types
		case "string", "bool", "float64":
			return mappedFields{fieldMapping: "z." + prefix + name, name: prefix + name}, nil
		case "int64":
			// special case for converting time fields and arrays of times
			m := mappedFields{fieldMapping: "z." + prefix + name, name: prefix + name}
			fieldType := generatedField.Type
			pointer := false
			if p, ok := generatedField.Type.(*ast.StarExpr); ok {
				pointer = true
				fieldType = p.X
			}
			if selector, ok := fieldType.(*ast.SelectorExpr); ok && selector.Sel.Name == "Time" {
				m = mappedFields{fieldMapping: fmt.Sprintf("generate.AvroTime(z.%s)", prefix+name), name: prefix + name}
			}
			if gArray, ok := fieldType.(*ast.ArrayType); ok {
				aType := gArray.Elt
				if p, ok := gArray.Elt.(*ast.StarExpr); ok {
					aType = p.X
					pointer = true
				}
				if selector, ok := aType.(*ast.SelectorExpr); ok && selector.Sel.Name == "Time" {
					m = mappedFields{fieldMapping: fmt.Sprintf("generate.AvroTimeSlice(z.%s)", prefix+name), name: prefix + name}
				}
			}
			if pointer {
				m.fieldMapping = strings.Replace(m.fieldMapping, "generate.AvroTime", "generate.AvroOptionalTime", 1)
			}
			return m, nil
		}
		// If not a built in type it could be a special Avro Union type
		if tmpl, ok := fm.unionTemplates[typeName]; ok {
			buf := &bytes.Buffer{}
			format := map[string]string{"packageName": fm.packageName, "value": "z." + prefix + name}
			// special case for converting time fields
			fieldType := generatedField.Type
			pointer := false
			if p, ok := generatedField.Type.(*ast.StarExpr); ok {
				pointer = true
				fieldType = p.X
			}
			if selector, ok := fieldType.(*ast.SelectorExpr); ok && selector.Sel.Name == "Time" {
				format = map[string]string{"packageName": fm.packageName, "value": fmt.Sprintf("generate.AvroTime(z.%s)", prefix+name)}
			}
			if err := tmpl.Execute(buf, format); err != nil {
				return mappedFields{}, fmt.Errorf("failed union template: %v", err)
			}
			m := mappedFields{fieldMapping: buf.String(), name: typeName}
			if pointer {
				m.fieldMapping = strings.Replace(m.fieldMapping, "generate.AvroTime", "generate.AvroOptionalTime", 1)
			}

			return m, nil
		}

		if strings.HasPrefix(typeName, "UnionNull") {
			childTypeName := strings.TrimPrefix(typeName, "UnionNull")
			mf, err := fm.generateStructValue(name, prefix, childTypeName, generatedField)
			if err != nil {
				return mappedFields{}, fmt.Errorf("failed generating UnionNull struct value: %v", err)
			}
			buf := &bytes.Buffer{}
			templateData := map[string]string{
				"packageName": fm.packageName,
				"typeName":    childTypeName,
				"value":       mf.fieldMapping,
			}
			if err := fm.unionNullStructTemplate.Execute(buf, templateData); err != nil {
				return mappedFields{}, fmt.Errorf("failed generating UnionNull struct template: %v", err)
			}
			return mappedFields{fieldMapping: buf.String(), preProcessing: mf.preProcessing, name: typeName}, nil
		}

		return fm.generateStructValue(name, prefix, typeName, generatedField)
	}
	return mappedFields{}, fmt.Errorf("unhandled type for field %q", prefix+name)
}

func (fm *avroFieldMapper) generateNullableFieldValue(name, prefix, fieldTypeName, fieldValue string) string {
	returnType := fmt.Sprintf("*%s.%s", fm.packageName, fieldTypeName)
	return fmt.Sprintf(
		`func() %s {
	var s %s
	if z.%s != nil {
		s = %s
	}
	return s
}()`, returnType, returnType, prefix+name, fieldValue)
}

// generateStructValue will generate code to match an Avro struct or array of structs with values from the generated
// Go struct.
func (fm *avroFieldMapper) generateStructValue(name, prefix, typeName string, generatedField *ast.Field) (mappedFields, error) {
	avroStruct, err := parseGoStruct(typeName, fm.avroPackagePath)
	if err != nil {
		return mappedFields{}, fmt.Errorf("error parsing go struct type %s: %v", typeName, err)
	}
	avroFields := findStructFields(avroStruct)
	if avroFields == nil {
		return mappedFields{}, fmt.Errorf("failed parsing fields from type %s", typeName)
	}

	if aType, ok := generatedField.Type.(*ast.ArrayType); ok {
		mappedStruct, fields, err := fm.generateChildStruct(aType.Elt, prefix+name, "", avroFields)
		if err != nil {
			return mappedFields{}, err
		}

		var structDef string
		if fields != nil {
			structDef = fmt.Sprintf("struct{%s}", printFields(fields))
		} else {
			structDef = mappedStruct.name
		}
		if _, ok := aType.Elt.(*ast.StarExpr); ok {
			structDef = "*" + structDef
		}

		funcName := typeName + "Slice"
		templValues := map[string]string{
			"funcName":     funcName,
			"typeID":       fmt.Sprintf("%s.%s", fm.packageName, typeName),
			"structDef":    structDef,
			"structFields": mappedStruct.fieldMapping,
		}

		buf := &bytes.Buffer{}
		if err := fm.structSliceTemplate.Execute(buf, templValues); err != nil {
			return mappedFields{}, fmt.Errorf("failed running struct slice template %v", err)
		}

		return mappedFields{
			fieldMapping:  fmt.Sprintf("%s(%s)", funcName, "z."+prefix+name),
			preProcessing: mappedStruct.preProcessing + buf.String(),
		}, nil
	}

	mappedField, _, err := fm.generateChildStruct(generatedField.Type, prefix+name, prefix+name+".", avroFields)
	if err != nil {
		return mappedFields{}, err
	}

	return mappedFields{
		fieldMapping:  fmt.Sprintf("%s.%s{%s}", fm.packageName, typeName, mappedField.fieldMapping),
		preProcessing: mappedField.preProcessing,
	}, nil
}

type fieldListFinder struct {
	list *ast.FieldList
}

func (finder *fieldListFinder) Visit(node ast.Node) ast.Visitor {
	if list, ok := node.(*ast.FieldList); ok {
		finder.list = list
		return nil
	}
	return finder
}

func findStructFields(spec *ast.TypeSpec) *ast.FieldList {
	finder := &fieldListFinder{}
	ast.Walk(finder, spec)
	return finder.list
}

func mapGeneratedFields(name, goSourcePath string) (map[string]*ast.Field, error) {
	srcDir := filepath.Dir(goSourcePath)
	generatedStruct, err := parseGoStruct(name, goSourcePath)
	if err != nil {
		return nil, fmt.Errorf("failed to parse Go struct: %v", err)
	}
	generatedFields := findStructFields(generatedStruct)
	if generatedFields == nil {
		return nil, errors.New("failed to parse fields from go struct")
	}

	return mapFields(generatedFields, srcDir)
}

// mapFields walks through the fields in the field list building a map keyed by field name. Embedded structs are
// processed as though their fields are directly part of the fieldList. In the case of an embedded struct with a field
// which matches the name of a field not in the embedded struct the non-embedded version is preferred.
func mapFields(list *ast.FieldList, srcDir string) (map[string]*ast.Field, error) {
	length := list.NumFields()

	fieldMap := make(map[string]*ast.Field, length)
	for _, f := range list.List {
		if len(f.Names) == 0 { // an embedded struct
			t, ok := f.Type.(*ast.Ident)
			if !ok {
				continue
			}
			embedName := t.Name
			embedStruct, err := parseGoStruct(embedName, filepath.Join(srcDir, strings.ToLower(embedName)+".go"))
			if err != nil {
				return nil, fmt.Errorf("failed to parse embedded go struct %q: %v", embedName, err)
			}
			embedFields := findStructFields(embedStruct)
			if embedFields == nil {
				return nil, fmt.Errorf("no fields found for embedded go struct %q", embedName)
			}
			embedMap, err := mapFields(embedFields, srcDir)
			if err != nil {
				return nil, fmt.Errorf("failed to map fields for embedded go struct %q: %v", embedName, err)
			}
			for k, v := range embedMap {
				if _, ok := fieldMap[k]; !ok {
					fieldMap[k] = v
				}
			}
			continue
		}
		key := f.Names[0].Name
		fieldMap[key] = f
	}

	return fieldMap, nil
}

// printFields outputs the field definition for a struct as it was read from the original code.
func printFields(list *ast.FieldList) string {
	var out string
	for _, f := range list.List {
		if len(f.Names) < 1 {
			// Embedded struct, skipping for this
			continue
		}
		name := f.Names[0]

		switch fType := f.Type.(type) {
		case *ast.Ident:
			out += fmt.Sprintf("%s %s %s\n", name, fType.Name, f.Tag.Value)
		case *ast.ArrayType:
			// Handle the case where an array of structs is inside an array of structs.
			str, ok := fType.Elt.(*ast.StructType)
			if ok {
				out += fmt.Sprintf("%s []struct{\n%s} %s\n", name, printFields(str.Fields), f.Tag.Value)
				continue
			}

			ident, ok := fType.Elt.(*ast.Ident)
			if !ok {
				return "unknown array type"
			}
			out += fmt.Sprintf("%s []%s %s\n", name, ident.Name, f.Tag.Value)
		case *ast.SelectorExpr:
			if fType.Sel.Name != "Time" {
				return fmt.Sprintf(`unsupported type %q`, fType.Sel.Name)
			}
			out += fmt.Sprintf("%s time.Time %s\n", name, f.Tag.Value)
		case *ast.StructType:
			out += fmt.Sprintf("%s struct{\n%s} %s\n", name, printFields(fType.Fields), f.Tag.Value)
		}
	}
	return out
}

// writeCodeTemplate will execute a template from src with values and write to path.
// The assumption is this is go code so it will have standard go formatting applied.
func writeCodeTemplate(src string, values map[string]string, path string) error {
	buf := &bytes.Buffer{}
	tmpl, err := template.New("").Parse(src)
	if err != nil {
		return fmt.Errorf("failed to parse template: %v", err)
	}
	if err := tmpl.Execute(buf, values); err != nil {
		return fmt.Errorf("failed to execute code generation template: %v", err)
	}

	// Apply go formatting
	final, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format source: %v", err)
	}

	if err := ioutil.WriteFile(path, final, 0644); err != nil {
		return fmt.Errorf("failed to write file %q: %v", path, err)
	}

	return nil
}
